*Pessoal eu iniciei nossa wiki, e coloquei nela tudo que desenvolvemos*
*até agora (arquivo em .doc, algoritmo, e assembly), ok? *
*Só não estou conseguindo colocar as figuras ainda. Paula Alves.*


*RESTA 1*

*Integrantes:*

Clodoaldo Ribeiro dos Santos 482773
Maiara Guimaraes Flausino 435589
Marcelo Vieira Arjona 434558 
Paula Gabriela Mota Alves 483125
Vanderli Gilson de Sousa 482765
Vitor Alves de Andrade 435970

*INTRODUÇÃO*

Como foi propsto na matéria de Arquitetura de Computadores um desenvolvimento de um jogo em Assembly, decidi-se pelo jogo resta-um, que é um jogo solitário cujo objetivo é conseguir deixar apenas uma peça no tabuleiro que comportavam inicialmente várias peças. 
Como todo jogo, há regras, as quais permitem que um peça no tabuleiro possa “eliminar” outra peça em posição adjacente horizontal ou verticalmente aquela, sendo que a posição alcançada é a posição vizinha da peça eliminada.

*OBJETIVO*

O objetivo deste trabalho é consolidar os conhecimentos sobre a linguegem assembly, desnvolvendo um jogo “resta-um”, a fim de colocar em prática os conhecimentos teóricos adquiridos na matéria. 

*ALGORITMO*

{

Estou fazendo uma algoritmo para direcionar nosso trabalho, travei um pouco na hora em que a peça passa por cima da outra como fazer as verificações se alguém puder ajudar.

}


{ Algoritmo do jogo Resta 01 }

Declare:

vetor[7][7]: tipo char
verificar: tipo inteiro
linha, coluna: tipo inteiro
l, c: tipo inteiro


{ iniciar o vetor }

para i <- 0 até i < 7

para j = 0 até 7 faça

se j < 3 e i < 3 ou i > 6 faça

vetor[i][j] <- " "

senão

vetor[i][j] <- X { Peças do jogo e um vetor recebe vazio }

fim para

fim para

vetor[4][4] <- " " { vazio, zerando a posição do do jogo }

c <- 0
l <- 0


faça enquanto

escreva "Digite a opção desejada"
escreva "0 para sair"
escreva "Escolha a Linha de 1 a 7"
escreva "Escolha a Coluna de 1 a 7"

leia Linha
leia Coluna

se linha ou coluna = 0 então

fim algoritmo

senão

se vetor[linha][coluna] = " " ou linha > 7 ou coluna > 7então

escreve "Posição invalida"

senão


leia l {Pegar onde o usario quer jogar }
leia c {Pegar onde o usario quer jogar }

se vetro[l][c] <> " " ou l > 7 ou c > 7 então

escreva "Opção invalida"

senão

se c < 3 e l < 3 ou c > 5 e l < 3 ou c < 3 e l > 5 ou c > 3 e l > 5 então

escreva "Opção invalida"

senão

se linha - l > 2 ou < - 2 ou coluna - c > 2 ou < -2 então

escreva "Opção invalida"

senão

se linha = l então

se coluna > c então

se vetor[linha][coluna - 1] <> " "

vetor[linha][coluna - 1] <- " "

senão

escreva "Jogada invalida"

fim - se

senão
se vetor[linha][coluna + 1] <> " "

vetor[linha][coluna + 1] <- " "

senão

escreva "Jogada invalida"


fim - se

fim - se

se coluna = c

se linha > l então

se vetor[linha-1][coluna] <> " " então

vetor[linha-1][coluna] <- " "

senão

escreva "Jogada invalida"

fim - se


senão

se vetor[linha+1][coluna] <> " " então

vetor[linha+1][coluna] <- " "

senão

escreva "Jogada invalida"

fim - se


fim - se


fim - se

se linha <> l e coluna <> c então

se linha > l e coluna > c então

se vetor[linha - 1][coluna - 1] <> " " então

vetor[linha - 1][coluna - 1] <- " "

senão

escreva "Jogada invalida"

fim - se


se linha < l e coluna < c então

se vetor[linha + 1][coluna - 1] <> " " então

vetor[linha + 1][coluna - 1] <- " "

senão

escreva "Jogada invalida"

fim - se



se linha > l e coluna < c então

se vetor[linha - 1][coluna + 1] <> " " então

vetor[linha - 1][coluna + 1] <- " "

senão

escreva "Jogada invalida"

fim - se



se linha < l e coluna > c então

se vetor[linha + 1][coluna - 1] <> " " então

vetor[linha + 1][coluna - 1] <- " "

senão

escreva "Jogada invalida"

fim - se



fim - se


fim - se


fim - se

fim - se

fim - se

fim se

fim faça


*ASSEMBLY MIPS*

# GAME: RESTA UM
# DISCIPLINA: ARQUITETURA DE COMPUTADORES


# DECLARAÇÃO DOS DADOS
	.data


# Globals
pino_coord:
	.space 	49	# vetor de 49 pinos
			
# TABULEIRO DO JOGO
casa_vazia:
	.asciiz " "


casa_cheia:
	.asciiz "O"
	
mensagem_inicio:
	.asciiz	"*GAME: RESTA UM*"
	
mensagem_atual:
	.asciiz	"\nDigite o local para onde peça está: "
	
mensagem_mover:
	.asciiz	"\nDigite o local para onde peça irá se mover: "


PLAYER_QUIT_MSG:
	.asciiz "\nPlayer quit."


		
# Desenhar tabuleiro
tabuleiro_topo:
	.asciiz		"   0123456\n"
margem_vertical:
	.asciiz			"    -----\n"
linha_0:
	.asciiz		"0   |"
linha_1:
	.asciiz		"1 -- "
linha_2:
	.asciiz		"2 |"
linha_3:
	.asciiz		"3 |"
linha_4:
	.asciiz		"4 |"
linha_5:
	.asciiz		"5 -- "
linha_6:
	.asciiz		"6   |"
margem_horizontal:
	.asciiz			" --\n"
tabuleiro_fim:
	.asciiz			"|\n"


espaco:
	.asciiz			"|      \n"


espaco2:
	.asciiz			"\n"	




# Texto
	.text


# 
# Programa principal
#
main:   
	# Mensagem inicial
	li	$v0, 4	
	la	$a0, mensagem_inicio
	syscall			


	# Iniciar o tabuleiro
	jal 	alocacao_tabuleiro
		


desenhar:
	jal	desenhar_tabuleiro






# Preenchimento do tabuleiro 


alocacao_tabuleiro:
        addi    $sp, $sp, -40	# alocação do tabuleiro no vetor na memoria
        sw      $ra, 32($sp)    # armazenar vetores na memória
        sw      $s7, 28($sp)
        sw      $s6, 24($sp)
        sw      $s5, 20($sp)
        sw      $s4, 16($sp)
        sw      $s3, 12($sp)
        sw      $s2, 8($sp)
        sw      $s1, 4($sp)
        sw      $s0, 0($sp)


	# Preparar para loops
	li	$s2, 7 		# Largura do tabuleiro
	
	li	$s0, 0 		# Linha atual


loop:
	# Repetição para próxima linha enquanto linha for menor que largura do tabuleiro.
	slt 	$t0, $s0, $s2				
	beq	$t0, $zero,  desenho_tabuleiro	#retornar


	li	$s1, 0		# Coluna atual
loop1:
	# Repetição para próxima coluna enquanto coluna for menor que largura do tabuleiro.
	slt	$t0, $s1, $s2				
	beq	$t0, $zero, loop3	
	
	# verificar se a coordenada é válida
	mul	$a0, $s0, 10		
	add	$a0, $a0, $s1			
	
	la	$t0, pino_coord
	add	$t1, $zero, $s0		
	mul	$t1, $t1, 7	
	add	$t1, $t1, $s1		
	
	add	$t0, $t0, $t1		
	sb	$v0, 0($t0)		
	
loop2:
	# loop interno
	addi	$s1, $s1, 1		# Coluna atual++
	j 	loop1	
	
loop3:
	#loop externo
	addi	$s0, $s0, 1		# Linha atual++
	j	loop		
desenho_tabuleiro:
        lw      $ra, 32($sp)   		# ler vetores do tabuleiro armazenados na memória
        lw      $s7, 28($sp)
        lw      $s6, 24($sp)
        lw      $s5, 20($sp)
        lw      $s4, 16($sp)
        lw      $s3, 12($sp)
        lw      $s2, 8($sp)
        lw      $s1, 4($sp)
        lw      $s0, 0($sp)
        addi    $sp, $sp, 40      	# limpar os dados
	jr	$ra




#Desenhar pinos


pino:
        addi    $sp, $sp, -40		# Alocar dos pinos no vetor na memoria
        sw      $ra, 32($sp)    
        sw      $s7, 28($sp)
        sw      $s6, 24($sp)
        sw      $s5, 20($sp)
        sw      $s4, 16($sp)
        sw      $s3, 12($sp)
        sw      $s2, 8($sp)
        sw      $s1, 4($sp)
        sw      $s0, 0($sp)
        
        move	$s0, $a0
        
	
desenhar_pino:
	li	$v0, 4	
	la	$a0, casa_cheia
	syscall


        
desenhar_casas:
        lw      $ra, 32($sp)    	# Ler vetores dos pinos armazenados na memoria
        lw      $s7, 28($sp)
        lw      $s6, 24($sp)
        lw      $s5, 20($sp)
        lw      $s4, 16($sp)
        lw      $s3, 12($sp)
        lw      $s2, 8($sp)
        lw      $s1, 4($sp)
        lw      $s0, 0($sp)
        addi    $sp, $sp, 40      	# limpar
        jr	$ra
        	
	


# Desenhar tabuleiro


desenhar_tabuleiro:
        addi    $sp, $sp, -40		# alocar vetores do tabuleiro na memoria para desenhar o tabuleiro
        sw      $ra, 32($sp)    
        sw      $s7, 28($sp)
        sw      $s6, 24($sp)
        sw      $s5, 20($sp)
        sw      $s4, 16($sp)
        sw      $s3, 12($sp)
        sw      $s2, 8($sp)
        sw      $s1, 4($sp)
        sw      $s0, 0($sp)
        
        # desenhar linhas inicio
        li	$v0, 4	
	la	$a0, espaco2
	syscall
	
        li	$v0, 4	
	la	$a0, tabuleiro_topo
	syscall	
	
	li	$v0, 4	
	la	$a0, margem_vertical
	syscall
	
	# desenhar linha 0


	
	li	$v0, 4	
	la	$a0, linha_0
	syscall
	
	li	$a0, 2
	jal	pino
	
	li	$a0, 3
	jal	pino
	
	li	$a0, 4
	jal	pino
	
	li	$v0, 4	
	la	$a0, espaco
	syscall
	
	# desenhar linha 1
	li	$v0, 4	
	la	$a0, linha_1
	syscall
	
	li	$a0, 12
	jal	pino
	
	li	$a0, 13
	jal	pino
	
	li	$a0, 14
	jal	pino
	
	li	$v0, 4	
	la	$a0, margem_horizontal
	syscall
	
	
	# desenhar linha 2
	li	$v0, 4	
	la	$a0, linha_2
	syscall
	
	li	$a0, 20
	jal	pino
	
	li	$a0, 21
	jal	pino
	
	li	$a0, 22
	jal	pino
	
	li	$a0, 23
	jal	pino
	
	li	$a0, 24
	jal	pino
	
	li	$a0, 25
	jal	pino
	
	li	$a0, 26
	jal	pino
		
	li	$v0, 4	
	la	$a0, tabuleiro_fim
	syscall
	
	# desenhar linha 3
	li	$v0, 4	
	la	$a0, linha_3
	syscall
	
	li	$a0, 30
	jal	pino
	
	li	$a0, 31
	jal	pino
	
	li	$a0, 32
	jal	pino
	
	li	$a0, 33
	la	$a0, casa_vazia
	syscall


	li	$a0, 34
	jal	pino
	
	li	$a0, 35
	jal	pino
	
	li	$a0, 36
	jal	pino
	
	li	$v0, 4	
	la	$a0, tabuleiro_fim
	syscall
	
	# desenhar linha 4
	li	$v0, 4
	la	$a0, linha_4
	syscall
	
	li	$a0, 40
	jal	pino
	
	li	$a0, 41
	jal	pino
	
	li	$a0, 42
	jal	pino
	
	li	$a0, 43
	jal	pino
	
	li	$a0, 44
	jal	pino
	
	li	$a0, 45
	jal	pino
	
	li	$a0, 46
	jal	pino
	
	li	$v0, 4	
	la	$a0, tabuleiro_fim
	syscall
	
	# desenhar linha 5
	li	$v0, 4	
	la	$a0, linha_5
	syscall
	
	li	$a0, 52
	jal	pino
	
	li	$a0, 53
	jal	pino
	
	li	$a0, 54
	jal	pino
	
	li	$v0, 4	
	la	$a0, margem_horizontal
	syscall
	
	# desenhar linha 6
	li	$v0, 4	
	la	$a0, linha_6
	syscall
	
	li	$a0, 62
	jal	pino
	
	li	$a0, 63
	jal	pino
	
	li	$a0, 64
	jal	pino
	
	li	$v0, 4	
	la	$a0, espaco
	syscall
	
	#fim do desenho
	li	$v0, 4	
	la	$a0, margem_vertical
	syscall


	
desenhar_tabuleiro_leitura:
        lw      $ra, 32($sp)    # ler dados alocados na memoria
        lw      $s7, 28($sp)
        lw      $s6, 24($sp)
        lw      $s5, 20($sp)
        lw      $s4, 16($sp)
        lw      $s3, 12($sp)
        lw      $s2, 8($sp)
        lw      $s1, 4($sp)
        lw      $s0, 0($sp)
        addi    $sp, $sp, 40      # limpar
        jr	$ra	



*RESTA 1*


A figura 1 ilustra um tabuleiro do jogo RESTA UM. Começa-se o jogo com peças em todas as casas, exceto em uma, que está inicialmente vazia. Nesse jogo, todas as peças podem ser movimentadas. No entanto, cada casa comporta, no máximo, uma peça.
Nesse jogo, a única jogada possível consiste em: dadas três casas consecutivas em linha, na horizontal ou na vertical, se uma das casas, que não a central, estiver vazia e as outras duas, ocupadas, uma das peças salta a outra, adjacente, retirando-se do jogo a que foi pulada. Se não for possível realizar a jogada, o jogo acaba.
Na Figura 2, vê-se a casa A vazia e as casas B e C ocupadas. A peça que está em C pula a que está em B e passa a ocupar a casa A. A peça da casa B, que foi pulada, é retirada do jogo (Figura 3).


Para eliminar uma bolinha, você precisa "pular" sobre ela, como no jogo de Damas. Para fazer isso, clique sobre a bolinha que vai pular outra que tenha uma casa vazia ao lado. 

Se houver mais de um movimento possível com a bolinha escolhida, aparecem sinais em vermelho para você escolher, clicando sobre um deles. 

Ganha-se o jogo quando resta apenas uma bolinha.
DESNVOLVIMENTO DO JOGO

Para a manipulação foi preciso a construção de um tabuleiro, como um vetor de 33 buracos. 
Foi preciso também definir algumas variáveis, como:
origem, buraco de onde o jogador selecionou a peça para movê-la;
pula, buraco vizinho imediato da origem que vai ser eliminado no final de um passo sucedido;
final, buraco onde a peça ficará depois de uma  jogada;
pecas, número de peças sobre o tabuleiro (atualizado a cada passo);
vencedor, 1 quando o jogador ganhou e 0 quando perdeu.
 
Passo a passo do jogo
Um passo do jogo consiste na seleção de uma peça pelo jogador, no deslocamento desta e termina quando a peça é solta.
 
*RESULTADOS*

Manual do usuário
Quando a janela de jogo se abre, o usuario pode começar a jogar selecionando uma peça com um clique e rastreando-a aonde quiser mantendo-se o botão esquerdo do mouse apertado. Uma vez a posição de destino atingida, é só liberar o botão do mouse. Se a jogada for impossível, a peça voltará ao seu lugar anterior. Caso contrário, ela ficará nesta posição e a peça pulada sumirá. 
No fim do jogo aparecerá na janela como as possíveis mensagens: você ganhou ou você perdeu. 

*CONCLUSÃO*

Este trabalho permitiu aplicar os conhecimentos teóricos da matéria Arquiterura de computado, sendo que o projeto de um jogo interativo obrigou os componentes do grupo a estudar mais detalhadamente a linguegem assembly.

*REFERÊNCIAS*